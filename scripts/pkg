#!/usr/bin/env bash

SCRIPT_DIR="$(cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd)"

source "$SCRIPT_DIR/log"

PKG_CONFIG_BLOCK_TOKENS="\
desc url version filecheck homepage \
sha256 configflags buildflags \
preinstall postinstall prebuild \
postbuild preconfig postconfig \
testspec patches installflags hash
"

# pkg_patchakra dir_patches 
pkg_patchakra() {
  local os=$HOST_OS
  local patches=$1
  
  if [ ! -d $1 ]; then 
    return 0
  fi

  log "Looking for patches to apply... in $1"

  for patch in $patches; do
    local apply=false
    local chunks=$(echo $patch | tr '-' ' ')
    set -- $chunks
    local criterias=$(echo $1 | tr '_' ' ')
    local desc=$2
    set -- $criterias

    # Version criteria
    if [[ "$2" =~ ^([\<\>\=])([0-9]+)(\.[0-9]+)*$ ]]; then
      local version="${2:1}"
      local matcher="${2:0:1}"
      if semver "$(os_dist_version) $matcher $version"; then
        apply=true  
      fi
    fi; 

    if [ $apply = true ];then
        patch -p0 -Nb < $patch
        if [ $? -eq 0 ]; then
          log --ok "Applied patch $patch"
        else
          log --err "Error when apply patch $patch"
          log_errexit "The process can't continue due a patch couldn't be able to be applied"
        fi
    fi 
  done 
}



pkg_config_read_value() {
  local fd varname tokens temp keepread
  local btokens="$(tr ' ' '|' <<<$PKG_CONFIG_BLOCK_TOKENS)"

  if [ -t 0 ] || [ -f "$1" ]; then
    fd=$1
    varname="$2"
    tokens="${@:3}"
  else
    varname="$1"
    tokens="${@:2}"
  fi

  if [ -z $tokens ]; then
    tokens="$btokens"
  else
    tokens="$(tr ' ' '|' <<<$tokens)|$btokens"
  fi
  while read -r line; do
    set -- $line
    if [[ "$1" =~ $tokens ]]; then
      if [[ "$1" == "$varname" ]]; then
        if [ ! -z $keepread ]; then
          log_errexit "Duplicated $1 token"
        fi
        keepread=1
        temp="${@:2}"
        temp="${temp%\"}"
        temp="${temp#\"}"
        temp="$temp"
      else
        keepread=
      fi
    elif [ ! -z $keepread ]; then
      temp+=" $line"
    fi
  done < <(cat $fd)

  echo "$temp"|tr -d '\\' | tr -d '\n'
}

pkg_config_parse_block() {
  local fd ctoken bcontent 
  local varexp varname varvalue
  local tokens
  local regex='\${?([a-z]+)\}?'

  if [ -t 0 ] || [ -e "$1" ]; then
    fd=$1
    tokens="${@:2}"
  else
    tokens="$@"
  fi
  
  while read -r line; do
    s="$line"
    while [[ "$line" =~ $regex ]]; do 
        varexp="${BASH_REMATCH[0]}"
        varname="${BASH_REMATCH[1]}"
        varvalue="$(echo -ne "$bcontent" | pkg_config_read_value $varname $tokens)"
        line="${line//$varexp/$varvalue}"
        s="${s#*"${BASH_REMATCH[1]}"}"
    done
    if [ -z "$bcontent" ]; then 
      bcontent="$(printf '%s\n' "$line")"
    else
      bcontent="$(printf '%s\n%s' "$bcontent" "$line")"
    fi

    echo "$line"
  done < <(cat $fd)
}

pkg_args_to_config() {
  set -- "$@"
  while [[ $# -gt 0 ]]; do
    case $1 in
      --|-)
        shift 1
      ;;
      --*|-*)
        if [[ "$1" =~ ^-- ]]; then
          varname=${1#"--"}
        else
          varname=${1#"-"}
        fi

        if [[ "$2" =~ ^--? ]] || [ -z "$2" ]; then
          echo "$varname true"
        else
          echo "$varname $2"
        fi
      ;;
    esac
    shift 1
  done
}

pkg_config_parse() {
  local fd args largs pkgconfig envconfig pkgname skip_os line tokens
  local tagpattern='^(\[([a-z0-9_-]+)\])$'

  if [ -t 0 ] || [ -e "$1" ]; then
    fd=$1
    args="${@:2}"
  else
    args="$@"
  fi
  
  largs=$(log_get_args $@)
  # parse the incoming flags from args to serialize as 
  # config to allow variable interpolation
  envconfig="$(pkg_args_to_config $args)"
  tokens="$(awk 'NR==1{printf "%s",$1}; NR>1{printf "|%s",$1}' <<< "$envconfig")"
  log $largs "env tokens detected: $(tr '|' ' ' <<< "$tokens")"
  
  while IFS= read -r line || [ -n "$line" ]; do
    if [ -z "$line" ] || [[ "$line" =~ ^[:space:]*# ]]; then 
      #ignore comments or empty lines
      continue
    elif [[ $line =~ ^(\[([a-z0-9_-]+)\])$ ]]; then
      if [ ! -z $pkgname ]; then 
        # add newline at the end for sanitize block
        if ! echo -ne "$pkgconfig\n" | pkg_config_parse_block $tokens | pkg_build_install $pkgname $tokens $largs; then
          exit 1
        fi
      fi
      skip_os= ; pkgconfig="$envconfig" ; pkgname=${BASH_REMATCH[2]}
      log $largs "detected config for $pkgname"
    elif [[ $line =~ ^(\(([darwin|linux]+)\))$ ]]; then
      log $largs "detected match os expresion for ${BASH_REMATCH[2]}"
      # set flag skip nexts lines until other os tag is detected and matched
      [[ ${BASH_REMATCH[2]} != $HOST_OS ]] && skip_os=1 || skip_os=
    elif [[ -z $skip_os ]]; then
      if [ -z "$pkgconfig" ]; then 
        pkgconfig="$(printf '%s\n' "$line")"
      else
        pkgconfig="$(printf '%s\n%s' "$pkgconfig" "$line")"
      fi
    else
      log $largs "skipping config line $line"
    fi
  done < <(cat $fd)

  if [ ! -z $pkgname ]; then
    echo -ne "$pkgconfig\n" | pkg_config_parse_block $tokens | pkg_build_install $pkgname $tokens $largs
  fi
}

pkg_build_install() {
  local fd args tokens envconfig \
        pkgname pkgconfig \
        sources filename extension \
        getval
  #local cflags=$(echo $@|awk -F' -- ' '{ print $2 }')
  local largs=$(log_get_args $@)
  local dryrun=$(is_flag_present --dry-run $@)

  if [ -t 0 ] || [ -e "$1" ]; then
    fd="$1"
    pkgname="$2"
    tokens="$3"
  else
    pkgname="$1"
    tokens="$2"
  fi
  
  if [ -z "$pkgname" ]; then
    log $largs --err "Empty package name\n" 
    log_errexit "The process can't continue due a package name must be provided"
  fi
  
  pkgconfig="$(cat $fd)"
  # create a custom function to extract the values from pkgconfig
  eval $"function pkg_config_block_read_value() {
    pkg_config_read_value \$1 "\"\$tokens\"" <<< "\"\$pkgconfig\"";
  }"
  
  local tempdir="$(pkg_config_block_read_value tempdir)"
  local toolchaindir="$(pkg_config_block_read_value toolchaindir)"
  local url="$(pkg_config_block_read_value url)"
  local filecheck="$(pkg_config_block_read_value filecheck)"
  local desc="$(pkg_config_block_read_value desc)"
  
  log $largs <(echo -ne "config details:\n$(echo -ne "$pkgconfig"|sed -e 's/^/-> /')")
  
  if [ -z "$tempdir" ]; then
    log $largs --err "Temporary directory must be defined" 
    log_errexit "The process can't continue due a temporary diretory must be provided"
  fi

  if [ ! -d "$tempdir" ]; then
    log $largs --err "Temporary directory must exists\n" 
    log_errexit "The process can't continue due a temporary diretory is not exist check $tempdir"
  fi

  sources=${pkgname}_src
  filename="${url##*/}"
  extension=${url##*.}

  log $largs "using temporary directory $tempdir"
  log_wrap $largs -- pushd $tempdir

  log $largs "using toolchain directory $toolchaindir"
  mkdir -p $toolchaindir
  
  log $largs --header "Installing $pkgname - $desc"
  
  if [ ! -z "$filecheck" ] && eval ls $filecheck &>/dev/null; then
    log $largs --ok "already installed"
    return 0
  fi
  
  if [ ! -d $sources ]; then
    if [ "$extension" == "git" ]; then
      pkg_clone $largs $sources
    elif [ ! -f $filename ]; then 
      pkg_download $largs $filename
      pkg_verify_checksum $largs $filename
    fi
  fi
  
  
  if [ ! -d $sources ] && [[ $extension == *"z"* ]]; then
    pkg_unpack $filename $sources $largs
  fi

  log_wrap $largs -- pushd $sources

  pkg_patch $largs
  pkg_configure $largs
  pkg_build $largs
  pkg_install $largs
  pkg_test $largs
}

pkg_clone() {
  local largs=$(log_get_args $@)
  local args=$(log_exclude_args $@)
  local url="$(pkg_config_block_read_value url)"
  local hash="$(pkg_config_block_read_value hash)"
  echo $hash
  if [ ! -z $hash ]; then 
    args=" --single-branch --branch $hash"
  fi
  
  log_wrap_process $largs "fetch sources from $url" -- git clone $url $args
}

pkg_download() {
  local largs=$(log_get_args $@)
  local args=$(log_exclude_args $@)
  local url="$(pkg_config_block_read_value url)"
  set -- $args
  
  trap "echo -ne >&2 '\n\nAborting, removing $1\n\n'; rm -f $1; exit 1" INT
  log_wrap_progress $largs --strip 1 "download $1" -- wget \
    --no-clobber \
    --quiet \
    --show-progress \
    --progress=bar:force \
    --output-document=$1 \
    "${@:2}" \
    $url
}

pkg_verify_checksum() {
  local sha256="$(pkg_config_block_read_value sha256)"
  local largs=$(log_get_args $@)
  local args=$(log_exclude_args $@)
  local dryrun=$(is_flag_present --dry-run $@)

  if [ -z $sha256 ]; then
    return 0
  fi

  set -- $args
  local cmd="shasum -a 256 $1 | awk '{ print \$1}'"

  if [ ! -z $dryrun ]; then
    echo $cmd
    return 0
  fi
  local checksum=$(eval $cmd)
  if [[ $checksum = $sha256 ]]; then
    log --ok $largs "check sha256sum $checksum"
  else
    log --err $largs "check sha256sum $checksum"
    log_errexit $largs <(cat <<-EOF
Wrong signature
  Actual: $checksum
  Expected: $sha256

EOF
)
  fi
}

pkg_unpack() {
  local largs=$(log_get_args $@)
  local args=$(log_exclude_args $@)
  local dryrun=$(is_flag_present --dry-run $@)
  local integrity
  set -- $args
  
  if [ -z $dryrun ]; then
    while IFS= read -r line; do
      integrity=1
      break;
    done < <(tar -tzf $1 2> /dev/null)

    if [ -z $integrity ]; then
      log_errexit "Error file integrity $1"
    fi
  fi

  log_wrap $largs -- mkdir -p $2
  log_wrap $largs -- pushd $2
  trap "echo -ne >&2 '\n\nAborting, removing $2\n\n'; rm -rf $2; exit 1" INT
  if ! log_wrap_progress $largs --strip 2 "unpack $1" -- \
      tar v --strip-components 1 -xf "../$1" ; then
    log_wrap $largs -- popd
    log_wrap $largs -- rm -rf $2
  fi
  log_wrap $largs -- popd
}

pkg_patch() {
  local largs=$(log_get_args $@)
  local args="$(log_exclude_args $@)"
  local patches="$(pkg_config_block_read_value patches)"
  
  if [ ! -z "$patches" ]; then
    pkg_patchakra $patches $args
  fi
}
pkg_configure() {
  local exit_code=0
  local largs=$(log_get_args $@)
  local args="$(log_exclude_args $@)"
  local configflags=$(pkg_config_block_read_value configflags)
  local prefix="$(pkg_config_block_read_value toolchaindir)"
  local preconfig="$(pkg_config_block_read_value preconfig)"
  local postconfig="$(pkg_config_block_read_value postconfig)"
  
  if [ ! -z "$preconfig" ]; then
    log_wrap_process $largs "pre-configure" -- \
      "$(echo -ne $preconfig)"
  fi
  
  if [ -f configure ]; then
    mkdir -p build
    log_wrap $largs -- pushd build
    log_wrap_process $largs "configure" -- \
      ../configure --prefix="$prefix" \
      $configflags
    exit_code=$?
    log_wrap $largs -- popd
  elif [ -f CMakeLists.txt ]; then
    log_wrap $largs -- mkdir -p build
    log_wrap $largs -- pushd build
    log_wrap_process $largs "configure" -- \
      cmake .. \
        -DCMAKE_C_FLAGS_RELEASE=-DNDEBUG \
        -DCMAKE_CXX_FLAGS_RELEASE=-DNDEBUG \
        -DCMAKE_INSTALL_PREFIX:PATH="$prefix" \
        -DCMAKE_BUILD_TYPE=Release \
        -DCMAKE_FIND_FRAMEWORK=LAST \
        -DCMAKE_VERBOSE_MAKEFILE=ON \
        -Wno-dev \
        $configflags
        
    exit_code=$?
    log_wrap $largs -- popd
  fi

  if [ ! -z "$postconfig" ]; then
    log_wrap_process $largs "post configure" -- \
      "$(echo -ne $postconfig)"
  fi

  return $exit_code
}

pkg_build() {
  local largs=$(log_get_args $@)
  local prebuild="$(pkg_config_block_read_value prebuild)"
  local postbuild="$(pkg_config_block_read_value postbuild)"
  local nproc=$(type nproc &> /dev/null && nproc || sysctl -n hw.ncpu)

  if [ ! -z $prebuild ]; then
    log_wrap_process $largs "pre-build" -- \
      "$prebuild"
  fi

  if [ -f build/Makefile ]; then
    log_wrap $largs -- pushd build
    log_wrap_process $largs "build" -- make -j$nproc
    log_wrap $largs -- popd
  elif [ -f Makefile ]; then
    log_wrap_process $largs "build" -- make -j$nproc
  fi  

  if [ ! -z $postbuild ]; then
    log_wrap_process $largs "post-build" -- \
      "$postbuild"
  fi
}

pkg_install() {
  local largs=$(log_get_args $@)
  local preinstall="$(pkg_config_block_read_value preinstall)"
  local postinstall="$(pkg_config_block_read_value postinstall)"
  local installflags="$(pkg_config_block_read_value installflags)"
  local toolchaindir="$(pkg_config_block_read_value toolchaindir)"

  if [ ! -z $preinstall ]; then
    log_wrap_process $largs "pre-install" -- \
      "$preinstall"
  fi

  if ls {bin,lib,include} &>/dev/null; then
    log_wrap_progress $largs "install" -- $(os_get_bin_path rsync) -vrzLR {bin,lib,include} "$toolchaindir/"
  elif [ -f build/Makefile ]; then
    log_wrap $largs -- pushd build
    log_wrap_process $largs "install" -- make install "$(echo -ne $installflags)"
    log_wrap $largs -- popd
  elif [ -f Makefile ]; then
    log_wrap_process $largs "install" -- make install "$(echo -ne $installflags)"
  fi

  if [ ! -z $postinstall ]; then
    log_wrap_process $largs "post-install" -- \
      "$postinstall"
  fi
}

pkg_test() {
  local largs=$(log_get_args $@)
  local args=$(log_exclude_args $@)
  local testspec="$(pkg_config_block_read_value testspec)"
  if [ ! -z "$testspec" ]; then
    log_wrap_process $largs "testing" -- "$testspec $args" 
  fi
}