#!/usr/bin/env bash

SCRIPT_DIR="$(cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd)"

source "$SCRIPT_DIR/log"

# pkg_patchakra dir_patches 
pkg_patchakra() {
  local os=$HOST_OS
  local patches=$1
  
  if [ ! -d $1 ]; then 
    return 0
  fi

  log "Looking for patches to apply... in $1"

  for patch in $patches; do
    local apply=false
    local chunks=$(echo $patch | tr '-' ' ')
    set -- $chunks
    local criterias=$(echo $1 | tr '_' ' ')
    local desc=$2
    set -- $criterias

    # Version criteria
    if [[ "$2" =~ ^([\<\>\=])([0-9]+)(\.[0-9]+)*$ ]]; then
      local version="${2:1}"
      local matcher="${2:0:1}"
      if semver "$(os_dist_version) $matcher $version"; then
        apply=true  
      fi
    fi; 

    if [ $apply = true ];then
        patch -p0 -Nb < $patch
        if [ $? -eq 0 ]; then
          log --ok "Applied patch $patch"
        else
          log --err "Error when apply patch $patch"
          log_errexit "The process can't continue due a patch couldn't be able to be applied"
        fi
    fi 
  done 
}



pkg_parse_config() {
  local filecontent
  local pkgconfig
  local pkgname
  local args
  local largs
  local skip_os
  local tagpattern="a-z0-9_-"
  
  if [ ! -t 0 ]; then
    filecontent=`cat`
    args="$@"
    largs=$(log_get_args $@)
  else
    filecontent=$(cat $1)
    args="${@:2}"
    largs=$(log_get_args $@)
  fi
  
  while IFS= read -r line; do
    if [[ $line == \#* ]]; then 
      continue
    fi
    if [[ $line =~ ^(\[([$tagpattern]+)\])$ ]]; then
      if [ ! -z $pkgname ]; then 
        echo -ne $pkgconfig | pkg_build_install $pkgname $args
      fi
      skip_os=
      pkgname=${BASH_REMATCH[2]}
      pkgconfig=
      log $largs "Detected $pkgname config"
    elif [[ $line =~ ^(\(([$tagpattern]+)\))$ ]]; then
        log $largs "Detected match os expresion for ${BASH_REMATCH[2]}"
        [[ ${BASH_REMATCH[2]} != $HOST_OS ]] && skip_os=1 || skip_os=
    elif [[ -z $skip_os ]]; then  
      [ ! -z "$line" ] && pkgconfig+="$line\n"
    fi
  done < <(echo -ne "$filecontent")

  if [ ! -z $pkgname ]; then 
    echo -ne $pkgconfig | pkg_build_install $pkgname $args
  fi
}

pkg_build_install() {
  local pkgname
  local pkgconfig
  local sources
  local filename
  local cflags=$(echo $@|awk -F' -- ' '{ print $2 }')
  local dflags
  local largs=$(log_get_args $@)
  local pkgargs=$(log_exclude_args $@)
  local tmpdir
  local patchesdir
  local toolchaindir
  local verbose
  local args
  local nproc=$(type nproc &> /dev/null && nproc || sysctl -n hw.ncpu)

  local ctoken
  local tcontent
  
  set -- $pkgargs
  
  if [ ! -t 0 ]; then
    pkgname="$1"
    pkgconfig="$(cat)"
    shift 1
  elif [ -e "$1" ]; then
    pkgname="$2"
    pkgconfig="$(cat "$1")"
    shift 2
  else
    log_errexit $largs "Error a config must be provided" 
  fi

  log $largs <(echo -ne "Config details:\n$(echo -ne "$pkgconfig"|sed -e 's/^/-> /')")
  
  while [[ $# -gt 0 ]]; do
    case $1 in
      -t|--tempdir)
        tmpdir="$2"
        shift 2
      ;;
      -T|--toolchaindir)
        toolchaindir="$2"
        shift 2
      ;;
      -p|--patchesdir)
        patchesdir="$2"
        shift 2
      ;;
      -D|--download-flags)
        dflags="$2"
        shift 2
      ;;
      --)
        break
      ;;
      *)
        break;
      ;;
    esac
  done 

  sources=${pkgname}_src
  
  if [ -z "$tmpdir" ]; then
    log $largs --err "Temporary directory must be defined\n" 
    log_errexit "The process can't continue due a temporary diretory must be provided"
  fi

  if [ ! -d "$tmpdir" ]; then
    log $largs --err "Temporary directory must exists\n" 
    log_errexit "The process can't continue due a temporary diretory is not exist check $tmpdir"
  fi
  
  while read -r line; do
    set -- $line
    case $1 in 
      url|version|filecheck|homepage|\
      sha256|configflags|buildflags|\
      preinstall|postinstall|prebuild|\
      postbuild|preconfig|postconfig|\
      testspec|patches)
        if [ ! -z "$ctoken" ]; then
          tcontent="$(eval "\
            export toolchaindir="${toolchaindir}"; \
            export version="${version}"; \
            echo -ne '$tcontent'")"
          # nasty way to create dynamic variable due 
          # there's no way to make an associative array in bash 3
          eval "local $ctoken="\"$tcontent\"""
        fi
        ctoken="$1"
        tcontent="${@:2}"
      ;;
      \#*)
        #ignore comments
      ;;
      *)
        tcontent+="\n$line"
      ;;
    esac 
  done < <(echo -ne "$pkgconfig")
  
  if [ ! -z "$ctoken" ]; then
    eval "local $ctoken="\"$tcontent\"""
  fi
  
  filename="${url##*/}"
  extension=${url##*.}

  log $largs "using temporary directory $tmpdir"
  pushd $tmpdir > /dev/null
  
  log $largs --header "Installing $pkgname"
  
  if [ ! -z "$filecheck" ] && ls $filecheck &>/dev/null; then
    log $largs --ok "already installed $pkgname"
    return 0
  fi
  
  if [ "$extension" == "git" ] && [ ! -d $sources ]; then
    pkg_clone $url $sources $version $largs
  elif [ ! -f $filename ]; then 
    pkg_download $url $filename $largs
    if [ ! -z $sha256 ]; then
      pkg_verify_checksum $filename $sha256 $largs
    fi
  fi
  
  exit 0

  ## Unpacking
  if [ ! -d $sources ]; then
    mkdir -p $sources
    pushd $sources > /dev/null
    if ! log_wrap_progress $largs --strip 2 "unpack" -- \
       tar v --strip-components 1 -xf "../$filename"; then
      popd
      rm -rf $sources
    fi
    popd > /dev/null
  fi

  ## Patching
  if [ ! -z "$patches" ]; then
    pushd $sources > /dev/null
    pkg_patchakra $patches
    popd > /dev/null
  fi

  pushd $sources > /dev/null

  if [ ! -z "$preconfig" ]; then
    log_wrap_process $largs "pre-configure" -- \
      "$preconfig"
  fi

  if [ -f configure ]; then
    mkdir -p build
    pushd build > /dev/null
    log_wrap_process $largs "configure" -- \
      ../configure $cflags --prefix="$toolchaindir" $configflags
    popd > /dev/null
  fi

  if [ ! -z "$postconfig" ]; then
    log_wrap_process $largs "post configure" -- \
      "$postconfig"
  fi

  if [ -f build/Makefile ] || [ -f Makefile ]; then
    pushd $(dirname $(ls {build,.}/Makefile 2>/dev/null)) > /dev/null

    if [ ! -z $prebuild ]; then
      log_wrap_process $largs "pre-build" -- \
        "$prebuild"
    fi

    log_wrap_process $largs "build" -- make -j$nproc

    if [ ! -z $postbuild ]; then
      log_wrap_process $largs "post-build" -- \
        "$postbuild"
    fi

    if [ ! -z $preinstall ]; then
      log_wrap_process $largs "pre-install" -- \
        "$preinstall"
    fi

    log_wrap_process $largs "install" -- make install
    
    if [ ! -z $postinstall ]; then
      log_wrap_process $largs "post-install" -- \
        "$postinstall"
    fi
    popd > /dev/null
  elif ls {bin,lib} &>/dev/null; then
    log_wrap_progress $largs "install" -- rsync -vrzLR {bin,lib} "$toolchaindir/"
  fi

  if [ ! -z "$testspec" ]; then
    log_wrap_process $largs "testing $pkgname" -- "$testspec"
  fi

  popd > /dev/null
  
  popd > /dev/null
}

# pkg_unpack() {

# }

# pkg_build(){

# }

# pkg_install(){

# }

pkg_clone() {
  local largs=$(log_get_args $@)
  local args=$(log_exclude_args $@)
  set -- $args
  log_wrap_process $largs "fetch sources from $1" -- git clone $1 $2
  if [ ! -z $3 ]; then
    log_wrap $largs -- pushd $2
    log_wrap_process $largs "select branch $1" -- git checkout $3
    log_wrap $largs -- popd
  fi
}

pkg_download() {
  local largs=$(log_get_args $@)
  local args=$(log_exclude_args $@)
  set -- $args
  log_wrap_process $largs --show "download" -- "wget \
    --no-clobber \
    --progress=bar:force 2>&1 \
    --output-document=$2 \
    ${@:3} \
    $1 \
    | log_wrap_wget_progress $largs"
}

pkg_verify_checksum() {
  local largs=$(log_get_args $@)
  local dryrun=$(is_flag_present --dry-run $@)
  local args=$(log_exclude_args $@)
  set -- $args
  local cmd="shasum -a 256 $1 | awk '{ print \$1}'"

  if [ ! -z $dryrun ]; then
    echo $cmd
    return 0
  fi
  local checksum=$(eval $cmd)
  echo "checksum $checksum"
  if [[ $checksum = $2 ]]; then
    log --ok $largs "check sha256sum"
  else
    log --err $largs "check sha256sum"
    log_errexit $largs <(cat <<-EOF
Wrong signature
  Actual: $checksum
  Expected: $2

EOF
)
  fi
}