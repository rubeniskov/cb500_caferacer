#!/usr/bin/env bash

SCRIPT_DIR="$(cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd)"

source "$SCRIPT_DIR/log"

# pkg_patchakra dir_patches 
pkg_patchakra() {
  local os=$HOST_OS
  local patches=$1
  
  if [ ! -d $1 ]; then 
    return 0
  fi

  log "Looking for patches to apply... in $1"

  for patch in $patches; do
    local apply=false
    local chunks=$(echo $patch | tr '-' ' ')
    set -- $chunks
    local criterias=$(echo $1 | tr '_' ' ')
    local desc=$2
    set -- $criterias

    # Version criteria
    if [[ "$2" =~ ^([\<\>\=])([0-9]+)(\.[0-9]+)*$ ]]; then
      local version="${2:1}"
      local matcher="${2:0:1}"
      if semver "$(os_dist_version) $matcher $version"; then
        apply=true  
      fi
    fi; 

    if [ $apply = true ];then
        patch -p0 -Nb < $patch
        if [ $? -eq 0 ]; then
          log --ok "Applied patch $patch"
        else
          log --err "Error when apply patch $patch"
          log_errexit "The process can't continue due a patch couldn't be able to be applied"
        fi
    fi 
  done 
}



pkg_parse_config() {
  local filecontent
  local pkgconfig
  local pkgname
  local args
  local largs
  local skip_os
  local tagpattern="a-z0-9_-"
  
  if [ ! -t 0 ]; then
    filecontent=`cat`
    args="$@"
    largs=$(log_get_args $@)
  else
    filecontent=$(cat $1)
    args="${@:2}"
    largs=$(log_get_args $@)
  fi
  
  while IFS= read -r line; do
    if [[ $line == \#* ]]; then 
      continue
    fi
    if [[ $line =~ ^(\[([$tagpattern]+)\])$ ]]; then
      if [ ! -z $pkgname ]; then 
        if ! echo -ne $pkgconfig | pkg_build_install $pkgname $args; then
          exit 1
        fi
      fi
      skip_os=
      pkgname=${BASH_REMATCH[2]}
      pkgconfig=
      log $largs "detected $pkgname config"
    elif [[ $line =~ ^(\(([$tagpattern]+)\))$ ]]; then
        log $largs "detected match os expresion for ${BASH_REMATCH[2]}"
        [[ ${BASH_REMATCH[2]} != $HOST_OS ]] && skip_os=1 || skip_os=
    elif [[ -z $skip_os ]]; then  
      [ ! -z "$line" ] && pkgconfig+="$line\n"
    fi
  done < <(echo -ne "$filecontent")

  if [ ! -z $pkgname ]; then 
    echo -ne $pkgconfig | pkg_build_install $pkgname $args
  fi
}

pkg_build_install() {
  local pkgname ctoken tcontent args pkgconfig sources \
        filename tmpdir patchesdir toolchaindir
  local cflags=$(echo $@|awk -F' -- ' '{ print $2 }')
  local largs=$(log_get_args $@)
  local pkgargs=$(log_exclude_args $@)
  local dryrun=$(is_flag_present --dry-run $@)
  
  set -- $pkgargs
  
  if [ ! -t 0 ]; then
    pkgname="$1"
    pkgconfig="$(cat)"
    shift 1
  elif [ -e "$1" ]; then
    pkgname="$2"
    pkgconfig="$(cat "$1")"
    shift 2
  else
    log_errexit $largs "Error a config must be provided" 
  fi

  log $largs <(echo -ne "config details:\n$(echo -ne "$pkgconfig"|sed -e 's/^/-> /')")
  
  while [[ $# -gt 0 ]]; do
    case $1 in
      -t|--tempdir)
        tmpdir="$2"
        shift 2
      ;;
      -T|--toolchaindir)
        toolchaindir="$2"
        shift 2
      ;;
      -p|--patchesdir)
        patchesdir="$2"
        shift 2
      ;;
      -D|--download-flags)
        dflags="$2"
        shift 2
      ;;
      --)
        break
      ;;
      *)
        break;
      ;;
    esac
  done 

  sources=${pkgname}_src
  
  if [ -z "$tmpdir" ]; then
    log $largs --err "Temporary directory must be defined\n" 
    log_errexit "The process can't continue due a temporary diretory must be provided"
  fi

  if [ ! -d "$tmpdir" ]; then
    log $largs --err "Temporary directory must exists\n" 
    log_errexit "The process can't continue due a temporary diretory is not exist check $tmpdir"
  fi
  
  while read -r line; do
    set -- $line
    case $1 in 
      url|version|filecheck|homepage|\
      sha256|configflags|buildflags|\
      preinstall|postinstall|prebuild|\
      postbuild|preconfig|postconfig|\
      testspec|patches)
        if [ ! -z "$ctoken" ]; then
          tcontent="$(eval "\
            export toolchaindir="${toolchaindir}"; \
            export version="${version}"; \
            echo -ne '$tcontent'")"
          # nasty way to create dynamic variable due 
          # there's no way to make an associative array in bash 3
          eval "local $ctoken="\"$tcontent\"""
        fi
        ctoken="$1"
        tcontent="${@:2}"
      ;;
      \#*)
        #ignore comments
      ;;
      *)
        tcontent+="\n$line"
      ;;
    esac 
  done < <(echo -ne "$pkgconfig")
  
  if [ ! -z "$ctoken" ]; then
    eval "local $ctoken="\"$tcontent\"""
  fi
  
  filename="${url##*/}"
  extension=${url##*.}

  log $largs "using temporary directory $tmpdir"
  log_wrap $largs -- pushd $tmpdir

  log $largs "using toolchain directory $toolchaindir"
  mkdir -p $toolchaindir
  
  log $largs --header "Installing $pkgname"
  
  if [ ! -z "$filecheck" ] && ls $filecheck &>/dev/null; then
    log $largs --ok "already installed $pkgname"
    return 0
  fi
  
  if [ ! -d $sources ]; then
    if [ "$extension" == "git" ]; then
      pkg_clone $url $sources $version $largs
    elif [ ! -f $filename ]; then 
      pkg_download $url $filename $largs
      if [ ! -z $sha256 ]; then
        pkg_verify_checksum $filename $sha256 $largs
      fi
    fi
  fi
  
  ## Unpacking
  if [ ! -d $sources ] && [[ $extension == *"z"* ]]; then
    pkg_unpack $filename $sources $largs
  fi

  ## Patching
  if [ ! -z "$patches" ]; then
    log_wrap $largs -- pushd $sources
    pkg_patchakra $patches
    log_wrap $largs -- popd
  fi

  [ -z $dryrun ] && pushd $sources > /dev/null

  if [ ! -z "$preconfig" ]; then
    log_wrap_process $largs "pre-configure" -- \
      "$preconfig"
  fi

  pkg_configure $toolchaindir $configflags $largs

  if [ ! -z "$postconfig" ]; then
    log_wrap_process $largs "post configure" -- \
      "$postconfig"
  fi

  if [ ! -z $prebuild ]; then
    log_wrap_process $largs "pre-build" -- \
      "$prebuild"
  fi

  pkg_build $largs

  if [ ! -z $postbuild ]; then
    log_wrap_process $largs "post-build" -- \
      "$postbuild"
  fi

  if [ ! -z $preinstall ]; then
    log_wrap_process $largs "pre-install" -- \
      "$preinstall"
  fi

  pkg_install $toolchaindir $largs
  
  if [ ! -z $postinstall ]; then
    log_wrap_process $largs "post-install" -- \
      "$postinstall"
  fi

  if [ ! -z "$testspec" ]; then
    log_wrap_process $largs "testing $pkgname" -- "$testspec"
  fi
}

pkg_unpack() {
  local largs=$(log_get_args $@)
  local args=$(log_exclude_args $@)
  local dryrun=$(is_flag_present --dry-run $@)
  local integrity
  set -- $args
  
  if [ -z $dryrun ]; then
    while IFS= read -r line; do
      integrity=1
      break;
    done < <(tar -tzf $1 2> /dev/null)

    if [ -z $integrity ]; then
      log_errexit "Error file integrity $1"
    fi
  fi

  log_wrap $largs -- mkdir -p $2
  log_wrap $largs -- pushd $2
  trap "echo -ne >&2 '\n\nAborting, removing $2\n\n'; rm -rf $2; exit 1" INT
  if ! log_wrap_progress $largs --strip 2 "unpack" -- \
      tar v --strip-components 1 -xf "../$1" ; then
    log_wrap $largs -- popd
    log_wrap $largs -- rm -rf $2
  fi
  log_wrap $largs -- popd
}

pkg_build() {
  local largs=$(log_get_args $@)
  local args=$(log_exclude_args $@)
  local nproc=$(type nproc &> /dev/null && nproc || sysctl -n hw.ncpu)
  set -- $args

  if [ -f build/Makefile ] || [ -f Makefile ]; then
    log_wrap $largs -- pushd $(dirname $(ls {build,.}/Makefile 2>/dev/null))
    log_wrap_process $largs "build" -- make -j$nproc $@
    log_wrap $largs -- popd
  fi  
}

pkg_install(){
  local largs=$(log_get_args $@)
  local args=$(log_exclude_args $@)
  set -- $args

  if ls {bin,lib} &>/dev/null; then
    log_wrap_progress $largs "install" -- $(os_get_bin_path rsync) -vrzLR {bin,lib} "$1/"
  elif [ -f build/Makefile ] || [ -f Makefile ]; then
    log_wrap $largs -- pushd $(dirname $(ls {build,.}/Makefile 2>/dev/null))
    log_wrap_process $largs "install" -- make install
    log_wrap $largs -- popd
  fi
}

pkg_configure() {
  local largs=$(log_get_args $@)
  local args=$(log_exclude_args $@)
  local exit_code
  set -- $args

  if [ -f CMakeLists.txt ]; then
    log_wrap $largs -- mkdir -p build
    log_wrap $largs -- pushd build
    log_wrap_process $largs "configure" -- \
      cmake .. -DCMAKE_INSTALL_PREFIX:PATH="${1}" ${@:2}
    exit_code=$?
    log_wrap $largs -- pushd
  elif [ -f configure ]; then
    mkdir -p build
    log_wrap $largs -- pushd build
    log_wrap_process $largs "configure" -- \
      ../configure --prefix="$1" ${@:2}
    exit_code=$?
    log_wrap $largs -- popd
  fi

  return $exit_code
}

pkg_clone() {
  local largs=$(log_get_args $@)
  local args=$(log_exclude_args $@)
  local dryrun=$(is_flag_present --dry-run $@)
  set -- $args
  log_wrap_process $largs "fetch sources from $1" -- git clone $1 $2

  if [ ! -z $3 ]; then
    log_wrap $largs -- pushd $2
    log_wrap_process $largs "select branch $1" -- git checkout $3
    log_wrap $largs -- popd
  fi
}

pkg_download() {
  local largs=$(log_get_args $@)
  local args=$(log_exclude_args $@)
  
  set -- $args
  trap "echo -ne >&2 '\n\nAborting, removing $2\n\n'; rm -f $2; exit 1" INT
  log_wrap_progress $largs --strip 1 "download" -- wget \
    --no-clobber \
    --quiet \
    --show-progress \
    --progress=bar:force \
    --output-document=$2 \
    ${@:3} \
    $1
}

pkg_verify_checksum() {
  local largs=$(log_get_args $@)
  local dryrun=$(is_flag_present --dry-run $@)
  local args=$(log_exclude_args $@)
  set -- $args
  local cmd="shasum -a 256 $1 | awk '{ print \$1}'"

  if [ ! -z $dryrun ]; then
    echo $cmd
    return 0
  fi
  local checksum=$(eval $cmd)
  echo "checksum $checksum"
  if [[ $checksum = $2 ]]; then
    log --ok $largs "check sha256sum"
  else
    log --err $largs "check sha256sum"
    log_errexit $largs <(cat <<-EOF
Wrong signature
  Actual: $checksum
  Expected: $2

EOF
)
  fi
}