#!/usr/bin/env bash

SCRIPT_DIR="$(cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd)"

source "$SCRIPT_DIR/log"

# pkg_patchakra dir_patches 
pkg_patchakra() {
  local os=$HOST_OS
  local patches=$1
  
  if [ ! -d $1 ]; then 
    return 0
  fi

  log "Looking for patches to apply... in $1"

  for patch in $patches; do
    local apply=false
    local chunks=$(echo $patch | tr '-' ' ')
    set -- $chunks
    local criterias=$(echo $1 | tr '_' ' ')
    local desc=$2
    set -- $criterias

    # Version criteria
    if [[ "$2" =~ ^([\<\>\=])([0-9]+)(\.[0-9]+)*$ ]]; then
      local version="${2:1}"
      local matcher="${2:0:1}"
      if semver "$(os_dist_version) $matcher $version"; then
        apply=true  
      fi
    fi; 

    if [ $apply = true ];then
        patch -p0 -Nb < $patch
        if [ $? -eq 0 ]; then
          log --ok "Applied patch $patch"
        else
          log --err "Error when apply patch $patch"
          log_errexit "The process can't continue due a patch couldn't be able to be applied"
        fi
    fi 
  done 
}



pkg_parse_config() {
  local filecontent
  local pkgconfig
  local pkgname
  local args
  local lflags
  local skip_os
  local tagpattern="a-z0-9_-"
  
  if [ ! -t 0 ]; then
    filecontent=`cat`
    args="$@"
    lflags=$(log_get_flags $@)
  else
    filecontent=$(cat $1)
    args="${@:2}"
    lflags=$(log_get_flags $@)
  fi
  
  while IFS= read -r line; do
    if [[ $line == \#* ]]; then 
      continue
    fi
    if [[ $line =~ ^(\[([$tagpattern]+)\])$ ]]; then
      if [ ! -z $pkgname ]; then 
        echo -ne $pkgconfig | pkg_build_install $pkgname $args
      fi
      skip_os=
      pkgname=${BASH_REMATCH[2]}
      pkgconfig=
      log $lflags "Detected $pkgname config"
    elif [[ $line =~ ^(\(([$tagpattern]+)\))$ ]]; then
        log $lflags "Detected match os expresion for ${BASH_REMATCH[2]}"
        [[ ${BASH_REMATCH[2]} != $HOST_OS ]] && skip_os=1 || skip_os=
    elif [[ -z $skip_os ]]; then  
      [ ! -z "$line" ] && pkgconfig+="$line\n"
    fi
  done < <(echo -ne "$filecontent")

  if [ ! -z $pkgname ]; then 
    echo -ne $pkgconfig | pkg_build_install $pkgname $args
  fi
}

pkg_build_install() {
  local pkgname
  local pkgconfig
  local sources
  local filename
  local cflags=$(echo $@|awk -F' -- ' '{ print $2 }')
  local dflags
  local lflags=$(log_get_flags $@)
  local tmpdir
  local patchesdir
  local toolchaindir
  local verbose
  local args
  local nproc=$(type nproc &> /dev/null && nproc || sysctl -n hw.ncpu)

  local ctoken
  local tcontent
  
  if [ ! -t 0 ]; then
    pkgname=$1
    pkgconfig="$(cat)"
    shift 1
  else
    pkgname=$2
    pkgconfig="$(cat $1)"
    shift 2
  fi

  log $lflags <(echo -ne "Config details:\n$(echo -ne "$pkgconfig"|sed -e 's/^/-> /')")

  set -- $@

  while [[ $# -gt 0 ]]; do
    case $1 in
      -t|--tempdir)
        tmpdir="$2"
        shift 2
      ;;
      -T|--toolchaindir)
        toolchaindir="$2"
        shift 2
      ;;
      -p|--patchesdir)
        patchesdir="$2"
        shift 2
      ;;
      -D|--download-flags)
        dflags="$2"
        shift 2
      ;;
      -V|--verbose)
        verbose=1
        shift 1
      ;;
      --)
        break
      ;;
      *)
        break;
      ;;
    esac
  done 

  sources=${pkgname}_src
  
  if [ -z "$tmpdir" ]; then
    log $lflags --err "Temporary directory must be defined\n" 
    log_errexit "The process can't continue due a temporary diretory must be provided"
  fi

  if [ ! -d "$tmpdir" ]; then
    log $lflags --err "Temporary directory must exists\n" 
    log_errexit "The process can't continue due a temporary diretory is not exist check $tmpdir"
  fi
  
  while read -r line; do
    set -- $line
    case $1 in 
      url|version|filecheck|homepage|\
      sha256|configflags|buildflags|\
      preinstall|postinstall|prebuild|\
      postbuild|preconfig|postconfig|\
      testspec|patches)
        if [ ! -z "$ctoken" ]; then
          tcontent="$(eval "\
            export toolchaindir="${toolchaindir}"; \
            export version="${version}"; \
            echo -ne '$tcontent'")"
          # nasty way to create dynamic variable due 
          # there's no way to make an associative array in bash 3
          eval "local $ctoken="\"$tcontent\"""
        fi
        ctoken="$1"
        tcontent="${@:2}"
      ;;
      \#*)
        #ignore comments
      ;;
      *)
        tcontent+="\n$line"
      ;;
    esac 
  done < <(echo -ne "$pkgconfig")
  
  if [ ! -z "$ctoken" ]; then
    eval "local $ctoken="\"$tcontent\"""
  fi
  
  filename="${url##*/}"
  extension=${url##*.}
  signaturefile="${sha256##*/}"
  
  pushd $tmpdir > /dev/null
  
  log $lflags --header "Installing $pkgname"
  
  if [ ! -z "$filecheck" ] && ls $filecheck &>/dev/null; then
    log $lflags --ok "already installed $pkgname"
    return 0
  fi

  ## Download
  if [ "$extension" == "git" ] && [ ! -d $sources ]; then
      git clone $url $sources
      if [ ! -z $version ]; then
        pushd >/dev/null
        git checkout $version  
        popd >/dev/null
      fi
  else
    if [ ! -f $filename ]; then 
      log_wrap $lflags --show "download" -- pkg_download \
        $dflags \
        --output-document=$filename \
        $url
    fi

    if [ -f $filename ] && [ ! -z $sha256 ]; then
      sha256sum=$(sha256sum $filename | awk '{ print $1}')
      if [[ ! $sha256sum = $sha256 ]]; then
        log --err $lflags "check sha256sum"
        log_errexit $lflags <(cat <<-EOF
Wrong signature
  Actual: $sha256sum
  Expected: $sha256

EOF
)
      else
        log --ok $lflags "check sha256sum"
      fi
    fi
  fi

  ## Unpacking
  if [ ! -d $sources ]; then
    mkdir -p $sources
    pushd $sources > /dev/null
    if ! log_wrap_progress $lflags --strip 2 "unpack" -- \
       tar v --strip-components 1 -xf "../$filename"; then
      popd
      rm -rf $sources
    fi
    popd > /dev/null
  fi

  ## Patching
  if [ ! -z "$patches" ]; then
    pushd $sources > /dev/null
    pkg_patchakra $patches
    popd > /dev/null
  fi

  pushd $sources > /dev/null

  if [ ! -z "$preconfig" ]; then
    log_wrap $lflags "pre-configure" -- \
      "$preconfig"
  fi

  if [ -f configure ]; then
    mkdir -p build
    pushd build > /dev/null
    log_wrap $lflags "configure" -- \
      ../configure $cflags --prefix="$toolchaindir" $configflags
    popd > /dev/null
  fi

  if [ ! -z "$postconfig" ]; then
    log_wrap $lflags "post configure" -- \
      "$postconfig"
  fi

  if [ -f build/Makefile ] || [ -f Makefile ]; then
    pushd $(dirname $(ls {build,.}/Makefile 2>/dev/null)) > /dev/null

    if [ ! -z $prebuild ]; then
      log_wrap $lflags "pre-build" -- \
        "$prebuild"
    fi

    log_wrap $lflags "build" -- make -j$nproc

    if [ ! -z $postbuild ]; then
      log_wrap $lflags "post-build" -- \
        "$postbuild"
    fi

    if [ ! -z $preinstall ]; then
      log_wrap $lflags "pre-install" -- \
        "$preinstall"
    fi

    log_wrap $lflags "install" -- make install
    
    if [ ! -z $postinstall ]; then
      log_wrap $lflags "post-install" -- \
        "$postinstall"
    fi
    popd > /dev/null
  elif ls {bin,lib} &>/dev/null; then
    log_wrap_progress $lflags "install" -- rsync -vrzLR {bin,lib} "$toolchaindir/"
  fi

  if [ ! -z "$testspec" ]; then
    log_wrap $lflags "testing $pkgname" -- "$testspec"
  fi

  popd > /dev/null
  
  popd > /dev/null
}

pkg_download() {
    wget "$@" --progress=bar:force 2>&1 | log_wrap_wget_progress $@
}

