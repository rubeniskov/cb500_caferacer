#!/usr/bin/env bash

SCRIPT_DIR="$(cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd)"

source "$SCRIPT_DIR/common"

ESC_SEQ="\x1b["
COL_RESET=$ESC_SEQ"39;49;00m"
COL_RED=$ESC_SEQ"31;01m"
COL_GREEN=$ESC_SEQ"32;01m"
COL_YELLOW=$ESC_SEQ"33;01m"
COL_BLUE=$ESC_SEQ"34;01m"
COL_MAGENTA=$ESC_SEQ"35;01m"
COL_CYAN=$ESC_SEQ"36;01m"

# TABLE=<<-EOF
# --err error $COL_RED 1
# --ok ok $COL_GREEN 1
# --wrn warn $COL_YELLOW 1
# --header false $COL_GREEN 1
# EOF

log() {
  local ret
  local label
  local msg
  local color
  local cols=$(tput cols)
  local largs=$(log_get_args $@)
  local msg=$(log_get_args_label "$@")
  local logfile=$(log_get_args_logfile $@)
  local verbose=$(log_get_args_has_flag --verbose $@) 
  local showverb

  set -- $largs

  while [[ $# -gt 0 ]]; do
    case $1 in
      --err)
        label="error"
        color=$COL_RED
        showverb=1
        shift 1
        ;;
      --ok)
        label="ok"
        color=$COL_GREEN
        showverb=1
        shift 1
        ;;
      --prg:*)
        ret=1
        label=${1//--prg:/}
        color=$COL_YELLOW
        showverb=1
        shift 1
        ;;
      --wrn)
        label="warn"
        color=$COL_YELLOW
        showverb=1
        shift 1
        ;;
      --header)
        color=$COL_BLUE
        showverb=1
        shift 1
        ;;
      *)
        break;
      ;;
    esac
  done
  
  if [ -e "$msg" ]; then
    msg="$(cat $msg)"
  fi

  echo -ne "$msg\n" >> $logfile
  
  if [ -z $label ]; then
    if [ ! -z $color ]; then
      msg="$color$msg$COL_RESET"
    fi
  else
    if [ -z $color ]; then
      msg="[ $(printf "%5s" $label) ] $msg"
    else
      msg="[ $color$(printf "%5s" $label)$COL_RESET ] $msg"
    fi
  fi

  if [ ! -z $showverb ] || [ ! -z $verbose ]; then
    if [ ! -z $ret  ]; then
      echo -en >&2 "\033[K$msg\r"
    else
      echo -en >&2 "$msg\n"
    fi
  fi

  return 0
}

log_init() {
   log --logfile $1 "Using logfile $1"
   echo "" > "$1"
}

log_wrap() {
  local exit_code=0
  local cmd="$(log_wrap_get_cmd_args $@)"
  local largs="$(log_get_args $@)"
  local logfile=$(log_get_args_logfile $@)
  local verbose=$(log_get_args_has_flag --verbose $@)
  local show=$(log_get_args_has_flag --show $@)
  local dryrun=$(log_get_args_has_flag --dry-run $@)
  
  if [ ! -z $dryrun ]; then
    echo -ne "$cmd\n"
    return 0
  fi

  if [ ! -z $show ] || [ ! -z $verbose ]; then
    $cmd 2>&1 | tee -a $logfile
    exit_code=${PIPESTATUS[0]} 
  else
    $cmd 2>&1 >>$logfile
    exit_code=$?
  fi
  
  return $exit_code
}

log_wrap_process() {  

  local cmd="$(log_wrap_get_cmd_args "$@")"
  local largs="$(log_get_args "$@")"
  local label=$(log_get_args_label "$@")
  local dryrun=$(log_get_args_has_flag --dry-run $@) 

  if [ ! -z $dryrun ]; then
    log_wrap $largs -- "$cmd"
    return $?
  fi

  log $largs "Wrapping process -> $cmd"

  if log_wrap $largs -- "$cmd"; then 
    log $largs --ok "$label"
  else
    log $largs --err "$label"
    log_errexit $largs <(cat <<-EOF
Execution failed $cmd
EOF
)
  fi
}


log_wrap_progress() {
  local total=0
  local cmd="$(log_wrap_get_cmd_args "$@")"
  local label=$(log_get_args_label $@)
  local largs=$(log_get_args $@)
  local strip=$(fallback $(log_get_args_flag_value --strip $@) 0)
  
  log_wrap --show -- $cmd 2>&1 |\
  while read line; do
    stderr+=$line
    total=$((total+1))
    if [[ $line == '['* ]]; then
      log $largs "\033[K$line"
    else
      log $largs "--prg:$total" "$label ${line:$strip}"
    fi
  done

  exit_code=${PIPESTATUS[0]}
  
  if [ ! $exit_code -eq 0 ]; then
    log_errexit <<<$stderr
  fi

  return $exit_code
}

log_get_args_flag_value() {
  echo "$(get_flag_value $1 $(log_get_args ${@:2}))"
}

log_get_args_has_flag() {
  echo "$(is_flag_present $1 $(log_get_args ${@:2}))"
}

log_get_args_logfile() {
  local logfile="$(log_get_args_flag_value --logfile $@)"
  if [ -z $logfile ]; then
    echo "/dev/null"
  fi
  echo "$logfile"
}

log_wrap_get_cmd_args() {
  echo "$@" | awk -F' \\-\\- ' '{print $2}' 
}

log_get_args() {
  while [[ $# -gt 0 ]]; do
    case $1 in
      --logfile|--strip)
        echo -ne " $1 $2"
        shift 2
      ;;
      --verbose|--dry-run|\
      --show|--err|--ok|--prg:*|\
      --wrn|--header)
        echo -ne " $1"
        shift 1
      ;;
      *)
        shift 1
      ;;
    esac
  done
}

log_exclude_args() {
  local args
  while [[ $# -gt 0 ]]; do
    case $1 in
      --logfile|--strip)
        shift 2
      ;;
      --verbose|--dry-run|\
      --show|--err|--ok|--prg:*|\
      --wrn|--header)
        shift 1
      ;;
      *)
        args+=" $1"
        shift 1
      ;;
    esac
  done

  echo "${args:1}"
}

log_get_args_label() {  
  local label
  while [[ $# -gt 0 ]]; do
    case $1 in
      --logfile|--strip)
        shift 2
      ;;
      --verbose|--dry-run|\
      --show|--err|--ok|--prg:*|\
      --wrn|--header)
        shift 1
      ;;
      --)
        break
      ;;
      *)
        label+=" $1"
        shift 1
      ;;
    esac
  done

  echo ${label:1}
}

log_wrap_wget_progress() {
  local flag=false c count cr=$'\r' nl=$'\n'
  while IFS='' read -d '' -rn 1 c; do
    if $flag; then
      printf '%s' "$c"
    else
      if [[ $c != $cr && $c != $nl ]]; then
        count=0
      else
        ((count++))
        if ((count > 1)); then
          flag=true
        fi
      fi
    fi
  done
}

log_errexit() {
  local info
  local infoheader
  local cols=$(tput cols) 
  local logfile=$(log_get_args_logfile $@)

  info="$@"

  if [ -e "$1" ]; then
    info="$(cat $1)"
  fi

  if [ -f $logfile ]; then
    extrainfo=$(cat <<-EOF
Check the logfile $logfile to see more information:
$(tail $logfile|sed -e 's/^/-> /')
EOF
)
  fi

  echo -ne "$info\n" >> $logfile

  cat <<-EOF

Something wrong happend!! This may help you

$info

$extrainfo
EOF
  exit 1
}